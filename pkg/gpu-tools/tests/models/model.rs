use clap::Parser;
use tracing::debug;

use std::collections::HashMap;
use std::sync::{Arc, LazyLock};
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

use crate::models::phi3::{Model, ModelArgs};

#[derive(Parser, Debug, Clone)]
pub struct Args {
    /// GGUF file to load, typically a .gguf file generated by the quantize command from llama.cpp
    #[arg(long)]
    pub model_path: Option<String>,

    /// The length of the sample to generate (in tokens).
    #[arg(short = 'n', long, default_value_t = 1000)]
    pub sample_len: usize,

    /// The tokenizer config in json format.
    #[arg(long)]
    pub tokenizer_path: Option<String>,

    /// The temperature used to generate samples, use 0 for greedy sampling.
    #[arg(long, default_value_t = 0.6)]
    pub temperature: f64,

    /// Nucleus sampling probability cutoff.
    #[arg(long)]
    pub top_p: Option<f64>,

    /// Only sample among the top K samples.
    #[arg(long)]
    pub top_k: Option<usize>,

    /// The seed to use when generating random samples.
    #[arg(long, default_value_t = 299792458)]
    pub seed: u64,

    /// Enable tracing (generates a trace-timestamp.json file).
    #[arg(long)]
    pub tracing: bool,

    /// Process prompt elements separately.
    #[arg(long)]
    pub split_prompt: bool,

    /// Penalty to be applied for repeating tokens, 1. means no penalty.
    #[arg(long, default_value_t = 1.2)]
    pub repeat_penalty: f32,

    /// The context size to consider for the repeat penalty.
    #[arg(long, default_value_t = 64)]
    pub repeat_last_n: usize,

}

impl ModelArgs for Args {
    fn model_path(&self) -> anyhow::Result<std::path::PathBuf> {
        match &self.model_path {
            Some(path) => Ok(std::path::PathBuf::from(path)),
            None => Self::default_model_path()
        }
    }

    fn tokenizer_path(&self) -> anyhow::Result<std::path::PathBuf> {
        match &self.tokenizer_path {
            Some(path) => Ok(std::path::PathBuf::from(path)),
            None => Self::default_tokenizer_path()
        }
    }

    fn sample_len(&self) -> usize {
        self.sample_len
    }

    fn temperature(&self) -> f64 {
        self.temperature
    }

    fn top_k(&self) -> Option<usize> {
        self.top_k
    }

    fn top_p(&self) -> Option<f64> {
        self.top_p
    }

    fn seed(&self) -> u64 {
        self.seed
    }

    fn split_prompt(&self) -> bool {
        self.split_prompt
    }

    fn repeat_penalty(&self) -> f32 {
        self.repeat_penalty
    }

    fn repeat_last_n(&self) -> usize {
        self.repeat_last_n
    }
}

pub struct ModelManager {
    models: RwLock<HashMap<String, (Arc<RwLock<Model<Args>>>, Instant)>>,
    max_idle_time: Duration,
}

static MODEL_MANAGER: LazyLock<ModelManager> = LazyLock::new(|| ModelManager {
    models: RwLock::new(HashMap::new()),
    max_idle_time: Duration::from_secs(3600), // 1 hour default
});

impl ModelManager {
    pub fn instance() -> &'static ModelManager {
        &MODEL_MANAGER
    }

    pub async fn get_model(&self, session_id: String, args: &Args) -> anyhow::Result<Arc<RwLock<Model<Args>>>> {
        debug!("Attempting to get model for session: {}", session_id);
        let mut models = self.models.write().await;
        debug!("Acquired write lock on models HashMap");
        
        // Clean up old models
        let before_count = models.len();
        debug!("Current model count: {}", before_count);
        
        models.retain(|session_id, (_, last_used)| {
            let keep = last_used.elapsed() < self.max_idle_time;
            if !keep {
                debug!("Will drop model for session {}, idle for {:?}", session_id, last_used.elapsed());
            } else {
                debug!("Keeping model for session {}, idle for {:?}", session_id, last_used.elapsed());
            }
            keep
        });
        
        let dropped_count = before_count - models.len();
        if dropped_count > 0 {
            debug!("Cleaned up {} idle models, {} remaining", dropped_count, models.len());
        }
        
        if let Some((model, last_used)) = models.get_mut(&session_id) {
            debug!("Found existing model for session {}, last used {:?} ago", session_id, last_used.elapsed());
            *last_used = Instant::now();
            Ok(model.clone())
        } else {
            debug!("Creating new model for session {}", session_id);
            match Model::new(args).await {
                Ok(new_model) => {
                    debug!("Successfully created new model for session {}", session_id);
                    let model = Arc::new(RwLock::new(new_model));
                    models.insert(session_id, (model.clone(), Instant::now()));
                    debug!("Added new model to pool, total count: {}", models.len());
                    Ok(model)
                },
                Err(e) => {
                    debug!("Failed to create model for session {}: {}", session_id, e);
                    Err(e)
                }
            }
        }
    }
} 